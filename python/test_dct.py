#!/usr/bin/env python3
#
#-----------------------------------------------------------------------
# SAMPLE IMPLEMENTATION: INPAINTING
#-----------------------------------------------------------------------
#
import os
import numpy as np
import pnm
from scipy import fft
import paco
import patches


if __name__ == '__main__':
    """
    This tries to produce the same DCT values as generated by libjpeg's integer DCT
    it does not, as the integer DCT is approximate, but it is within +/- 1
    libjpeg actually produces (internally) 8 times the normalized values; we should
    remove this '8' when working in deblocking
    """
    img = pnm.imread('data/test_nacho.pgm').astype(int)
    M,N   = img.shape
    gm,gn = patches.grid_size(M,8,8),patches.grid_size(N,8,8)
    num = 0
    for ig in range(gm):
        for jg in range(gn):
            # transform
            num +=1
            i = ig*8
            j = jg*8
            x = img[i:(i + 8), j:(j + 8)] - 128 # this is what JPEG does
            print(f"input {num:06d}")
            for k in range(8):
                for l in range(8):
                    v = int(x[k, l])
                    print(f'{v:8d}', end='')
                print()
            print()
            #x = x - np.mean(x)
            z = fft.dctn(x,type=2,norm='ortho')
            print(f"output {num:06d}")
            for k in range(8):
                for l in range(8):
                    v = int(8*z[k,l])
                    print(f'{v:8d}',end='')
                print()
            print()